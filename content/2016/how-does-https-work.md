Title: Https是如何工作的
Category: Article
Tags: blog
Summary: Https的工作原理
picture: images/p.jpg

<center>Https是如何工作的?</center>
Https这个名词在日常编程中已经是习以为常了，写代码的时候也会涉及到相关的概念，那么为什么相关的代码要那样写，所以来讲下Https。

#### 密码系统(Cipher)
众所周知，如果我们要加密解密一些信息，我们必须要有一个key，就相当于如果你想打开一扇门或者锁上一扇门，你必须要有一把钥匙。  
在不同的编程语言中都有相应的生成key的库或者函数，可以生成对称加密的可以，也可以生成非对称加密的key。

* 对称加密的key  
  -- 加密跟解密用同一把钥匙  
* 非对称加密的key  
  -- 加密跟解密用的不是同一把钥匙，key通常分成公钥跟私钥。公钥可以被大范围的发布，然而私钥只有它的所有者才知道。
  在一个非对称加密的方案中，当信息被公钥加密了以后，只有私钥才能够对信息进行解密，所以，如果一个黑客，截取了你的公钥和你加密过的信息，他不能够对信息进行解密，因为他没有该公钥对应的私钥，所以这条消息的传输是安全的。

#### 证书(Certificate)  
在现实生活中，如果你到珠宝店里面买珠宝，你如何来判别这个珠宝是不是真的呢？一个普通人通常是没有任何珠宝知识的，但是如果每件珠宝都有一个被政府下发的许可证，那么你就会相信这个珠宝是真的了。  
证书(Certificate)的道理是一样的，在计算机世界里，证书通常会包括一些key和另外一个证书，暂且叫做证书B，其中的key是我所想要的，证书B就相当于一个许可证，来证明这个证书是可信的。  
那么问题来了，我怎么知道证书B是可信的呢？这是一个好问题。  
Android手机系统被内置了150多个根证书，这个150多个根证书是被全世界所信任的，就相当于是，他们是国家政府，你要相信你的政府。  
证书B中会包含另外一个证书C，所以我们要去检查证书C是不是可信的，我们依照这个证书链一层层向上检查，如果我们发现最后一个证书或者根证书是这150个证书里面的一个，那么一开始的那个证书B就是可信的了。

🏋🌰：
  * "x.509"  
  `x.509` 证书通常用来包含一个公钥。  
  * "PKCS12"  
  `PKCS12`证书也可以包含一个私钥，因此`PKCS12`证书需要一个密码来打开。  

#### Https   
最后，我们终于到了要谈谈https的时候了，因为https涵盖了上面所说的两点内容，所以，我要先在前面讲这两个部分。   
`https`(http over ssl) 是为了在网络上进行安全的通信而被设计的。  

##### 1.如何安全的通信？  
如何在网络上安全的进行通信？密码系统(Cipher)是我首先能够想到的。我在本地对我的数据进行加密，然后把加密后的数据和key一起传输到服务器上，然后服务器就能用我传给服务器的key来揭秘我的数据。
现在让我们来看看一个可能的场景：黑客窃听了你的通信，也就是说，他们已经有了key和加密过后的数据，显而易见，黑客有了你的key，有了用这个key加密过的数据，很容易的就把你的数据解密了，你的数据就此泄漏。  

#### 2.非对称加密又如何呢？   
我们上面第一点所说的就是对称加密， 就是加密跟解密用的是同一把🔑，显而易见这是很危险的，是不安全的，那么我们来看看非对称加密。  
这是一个好主意，我们来讲讲实现原理，首先服务器给了你它的公钥，然后你用这个公钥对你的数据进行加密，因为只有服务器有这个公钥所对应的私钥，也就是说只有这个私钥能够解密你的数据，从而保证了只有服务器能够解密你的数据。   
现在让我们来看看一个可能的场景：黑客窃听了你的通信，你的公钥跟公钥加密过的数据都被黑客得到了，但是由于黑客没有这个公钥所对应的私钥，所以就算他窃听了你的通信，获取了你的公钥跟数据，他还是无法知道这个被加密过的数据到底是什么。所以你的数据不会被泄漏。  
所以是不是觉得大功告成了，so easy，但是，非对称加密所要花费的时间要远远超过对称加密的时间，从用户的角度来考虑，用非对称加密的方式来加密一段很长的内容时，这并不是一个很好的解决方案。  
##### 3.最终的解决方案  
上面讲的两种方式到头来都是不可行的，那要是把上面的两种方式结合下呢？是的，这就是最终的解决方案。  
这种方式主要分为下面几个步骤：  
1. 【服务器】服务器在服务器端生成一堆钥匙串，包含了一个公钥一个私钥。  
2. 【服务器】服务器通过网络把公钥传输到客户端。
3. 【客户端】客户端在本地生成一个对称加密的key，然后用这个key加密我们的数据。
4. 【客户端】客户端用服务器生成的公钥来对在本地生成的key进行加密，所以在传输的时候本地生成的这个key就安全了，因为只有服务器才能对这个key进行解密。  
5. 【客户端】客户端把加密过后的数据和用公钥加密过后的key传输到服务器。  
6. 【服务器】服务器用自己的私钥来解密在客户端生成的那个对称加密的key。     
7. 【服务器】服务器用解密过后的key来解密我们的数据。  
上述过程计算被黑客劫持了，我们的数据也是安全的，黑客无法知道我们的数据具体是什么内容。  

#### 结论  
通过上面讲的第三种方法进行数据的传输，既能保证加密数据的时间很短，用户体验良好，用能保证数据的安全性。
